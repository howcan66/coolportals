R3 Panel Functionalities
------------------------

1. R3 presenterar ackordgrafik i form av pianografik.
   - Varje pianografik visar en oktav med vita och svarta tangenter.
   - Tangenternas notnamn ska alltid visas direkt på tangenterna.
   - Noter får aldrig döljas eller ersättas av annan grafik.

2. Pianografiken består av 10 fasta pianogrupper:
   - Dessa benämns R3.Pianogroup.1 till R3.Pianogroup.10.
   - Samtliga 10 pianogrupper ska placeras horisontellt på samma rad.
   - Ingen radbrytning får förekomma.
   - Pianogrupperna ska ligga kant-i-kant utan mellanrum.
   - R3-panelens bredd utgör 85% av sidans bredd (R1 upptar 15%).
   - De 10 pianogrupperna ska tillsammans fylla hela denna bredd.
   - Varje pianogrupp ska automatiskt anpassa sin bredd så att alla 10 får plats.
   - Pianogruppens höjd ska skalas proportionellt till dess bredd för att bibehålla korrekta pianoproportioner.
   - Ingen del av R3.Pianogroup får visa sidans bakgrund:
       * Ingen padding
       * Ingen margin
       * Ingen vit yta mellan grupperna

3. Tonmarkering i R3 är exkluderad:
   - Triad-markering: exkluderas
   - Tetrad-markering: exkluderas
   - Inversions-markering: exkluderas
   - Endast ackordnoter får markeras när ett ackord visas; inga extra overlays

4. Knappar för R3:
   - B7: Triad (ljudläge; minimal rund knapp utan text; primärt ljud; kan även trigga send till R2B om aktiverat)
   - B8: Tetrad (ljudläge; minimal rund knapp utan text; primärt ljud; kan även trigga send till R2B om aktiverat)
   - B9: Inversion (ljudläge; minimal rund knapp utan text; primärt ljud; kan även trigga send till R2B om aktiverat)
   - BR3: Load into R2B ("LR2B") (tyst; skickar senaste aktiva ackordet)

5. BR3-funktion:
    - BR3 ska skicka det SENAST AKTIVA ackordet i R3 (från R1/B1/B3) till R2B.
    - BR3 skickar alltid ett (1) ackord, aldrig en lista.
    - Payload ska följa gemensamt datakontrakt och innehålla föranalys (R3 analyserar inte själv).

5a. Gemensamt datakontrakt (R1→R3, R3→R2B):
{
   chordName: "Cmaj7",                    // Sträng
   notes: ["C4", "E4", "G4", "B4"],       // Voicing; display inom C4–B5, ljud kan behålla originaloktav
   mode: "triad" | "tetrad",              // Ljudläge
   inversion: 0..3,                         // 0=root, 1=1:a, 2=2:a, 3=3:e
   analysis: {                              // Föranalyserat i R1/R2A
      type: "Major Tetrad",
      intervals: ["R", "M3", "P5", "M7"],
      quality: "Major",
      position: "Root Position",
      extensions: ["7"],
      alterations: []
   },
   source: "R3",                           // "R1"|"R2A"|"R3" (metadata)
   timestamp: 1737734400000                 // valfritt
}

Validering innan send till R2B:
- chordName sträng, ≤20 tecken
- notes 2–6 st, format /^[A-G][#b]?[0-9]$/
- mode ∈ {triad, tetrad}; inversion 0–3
- analysis om finns: innehåller minst type och quality
- Vid fel: skicka inte, logga varning, behåll visning

6. Placering av knappar:
   - Knapparna B7, B8, B9 och BR3 ska placeras i en horisontell rad direkt under pianografiken.
   - Knapparna ska vara centrerade horisontellt i R3-panelen.
   - Knapparna ska vara små och runda, utan text på eller under knapparna (endast ikon/färgindikator om behövs).
   - Avståndet mellan knapparna ska vara jämnt.
   - Knapparnas rad ska ligga direkt under R3.Pianogroup-raden utan mellanliggande element.

7. R3-panelens bakgrundsfärg:
   - R3-panelens bakgrundsfärg är vit.

R3 Input From R1
----------------

1. R3 får alltid sitt aktiva ackord från R1.
   - R1 ansvarar för att välja eller aktivera ett ackord.
   - Det ackord som är aktivt i R1 ska omedelbart göras tillgängligt för R3.

2. R3 ska ta emot ackordet som ett enkelt ackordnamn (sträng):
   - Format: Ackordnamn (t.ex. "Cmaj7", "Dm", "F#dim")
   - R3 beräknar noter genom att tillämpa voicing-regler (avsnitt 9) baserat på aktuell läge (Triad/Tetrad) och inversion
   - Endast ett ackord åt gången är aktivt.

3. När R3 tar emot ett nytt ackord från R1:
   - Ackordnamn visas ovanför pianografiken (överlappar ej tangenter).
   - Tangenter för ackordets toner markeras; inga triad/tetrad/inversions-overlays.
   - Ingen annan källa får ändra R3:s aktiva ackord.

4. R3 ska alltid betrakta det senaste ackordet från R1 som det aktuella.
   - Tidigare ackord ska ignoreras.
   - Ingen historik sparas i R3.

5. R3 får inte själv generera eller ändra ackord.
   - R3 är en ren presentationspanel.
   - Endast R1 får bestämma vilket ackord som är aktivt.

R1-specifikation och triggers
-----------------------------
- Validering, rad/global-knappar (B1–B4) och hjälptexter hanteras i R1.
- Se "R1_Build AI Instruction_3.txt" för detaljer.

9. Ljudlägen och uppspelning
----------------------------
B7/B8/B9 styr ljudet i R3 (endast audio; visuella overlays exkluderas):
- B7 – Triad: spelar treklang utifrån ackordets kvalitet.
- B8 – Tetrad: spelar fyrklang = triad + primär extension (normalt 7; eller explicit 9/11/13; vid add9/add11/add13 används add-tonen).
- B9 – Inversion: cyklar inversioner, påverkar röstningsordning (lägsta ton) endast för ljud:
  * Triad: 0–2 (root, 1:a, 2:a)
  * Tetrad: 0–3 (root, 1:a, 2:a, 3:e)

Voicing-regler (tonuppsättning för uppspelning):
- maj: Triad R, 3, 5; Tetrad R, 3, 5, 7
- min: Triad R, b3, 5; Tetrad R, b3, 5, b7
- dom: Triad R, 3, 5; Tetrad R, 3, b7 + primär extension (9/11/13); 5 kan utgå vid behov
- sus: Triad R, 4, 5 (ersätter 3→4); Tetrad R, 4, 5, b7 (för dominant sus)
- dim: Triad R, b3, b5; °7 Tetrad R, b3, b5, bb7
- aug: Triad R, 3, #5; Tetrad R, 3, #5, 7 (om angivet)
- Alterationer: ersätt 5→#5/b5; använd #9/b9/#11/b13 som primär extension i tetradläge.
- Additions: add9/add11/add13 = använd add-ton som primär extension i tetradläge.

Inversionsordning (exempel):
- Triad inv0: R–3–5; inv1: 3–5–R; inv2: 5–R–3
- Tetrad inv0: R–3–5–7; inv1: 3–5–7–R; inv2: 5–7–R–3; inv3: 7–R–3–5

Utlösare → ljud:
- B1 (rad-load): spelar raden i valt läge/inversion (ett ackord per tryck; overflow n>10 ignoreras).
- B3 (load all): spelar alla laddade ackord sekventiellt i grupper 1–10; ~400 ms per ackord, ej överlapp.
- B2/B4 (clear/reset): tysta.
- BR3 (skicka till R2B): tyst; skickar endast senaste aktiva ackordet (aldrig lista).

Uppspelningsmotor standard:
- Polyfoni ≥ 4; blockackord som standard (samtidiga note-on).
- Envelope: attack 10–30 ms; sustain ~1–2 s; ingen pedal som standard.
- Stämning: A4 = 440 Hz; liksvävande temperament.

Edge cases:
- Ogiltiga ackord (enl R1.XC): tyst; rad rensas; R3 uppdateras inte.
- Overflow (B1 mot n>10): ignoreras; inget ljud.
- Fler än 4 toner: i tetradläge prioriteras primär extension; 5:e kan utgå för klar röstning.
- Enharmoniska: visning enligt inmatning; ljud spelar likvärdig tonklass (C# ≡ Db).

10. HTML Structure & Semantic Markup

   Container: <section id="r3-panel" class="r3-piano-panel"> för hela panelen.
   - Background: white (#ffffff)
   - Width: 85% of viewport

   Pianogroup Container: <div id="r3-pianogroups" class="r3-pianogroups-container">
   - Display: flex, no gap (kant-i-kant)
   - Flex-wrap: nowrap

   Individual Pianogroup Structure (×10):
   Individual Pianogroup contains chord label above piano SVG graphic
   - Chord label displays chord name or "–" if empty
   - Piano SVG shows one octave: C–B (12 notes, 7 white + 5 black keys)
   - Each key labeled with note name
   - Active chord notes marked in green (#8fd694)

   Button Container: <div class="r3-button-group"> direkt under pianogroups
   - B7, B8, B9: Small circular buttons (32px), data-mode attribute
   - BR3: Rounded square button with "LR2B" text
   - All buttons have aria-label for accessibility

   Footer: <div class="r3-footer"> för tidsstämpel
   - Format: yy.mm.dd • HH.mm (ex. "26.01.24 • 14.37")

11. CSS Styling Guidelines

   /* ===== PURPOSE: Define visual design for R3 pianogroup display =====
      GOAL: Render 10 professional-looking pianos in a horizontal row with clear visual feedback
      KEY PRINCIPLE: White background makes piano keys visible; green marking matches R1 color scheme.
                     Proportional scaling (aspect-ratio) keeps pianos readable at any screen size.
                     All 10 pianogroups must fit on ONE row (flex: 1 0 10% for equal width distribution).
      ===== */

   Color Palette:
   /* Why these colors? White background shows piano keys clearly (like real piano sheets).
      #8fd694 green matching R1 makes users recognize "marked notes" across panels.
      Gray for inactive buttons + light blue for active mode creates clear button state feedback. */
   - Background R3: #ffffff (white)
   - Piano white keys: #f5f5f5 (light gray)
   - Piano black keys: #1a1a1a (dark gray/black)
   - Marked tone (active chord): #8fd694 (green, per R1 consistency)
   - Button mode-inactive: #d0d0d0 (light gray)
   - Button mode-active: #a3d5ff (light blue)
   - Button BR3: #c9b3ff (light purple)

   R3 Panel Layout:
   /* Why 85% width? R1 takes 15% (input form), R3 takes 85% (visualization).
      This ratio balances input control with output display space.
      Flex column stacks pianogroups container on top of button group. */
   - Width: 85% of viewport
   - Display: flex, flex-direction: column
   - Background: #ffffff
   - Border: 1px solid #ddd

   Pianogroups Container:
   /* Why "kant-i-kant" (edge-to-edge)? No gaps between pianogroups makes the display seamless.
      If pianogroups had padding/margin, users would see white space between pianos (looks broken).
      Flex with gap:0 achieves this perfectly; nowrap prevents wrapping on small screens. */
   - Display: flex, gap: 0 (no space between groups, kant-i-kant)
   - Flex-wrap: nowrap
   - Width: 100%

   Individual Pianogroup:
   /* Why flex: 1 0 10%? "1" = grow equally; "0" = don't shrink below 10%; "10%" = 10% of container width.
      Result: 10 pianogroups each get exactly 10%, totaling 100% (the math works!)
      Aspect-ratio: 20:1 means if pianogroup is 100px wide, it becomes 5px tall (auto height).
      This keeps piano graphics readable at any viewport size. */
   - Flex: 1 0 10% (each takes 10% width)
   - Display: flex, flex-direction: column
   - Aspect-ratio: 20:1 (maintains piano proportions)

   Piano SVG:
   /* Why viewBox: 0 0 200 100? Defines coordinate system for SVG drawing.
      All 12 piano keys (7 white + 5 black) fit in this 200×100 space.
      This makes key positioning math simple and consistent across all renders. */
   - Width: 100%, Height: auto
   - viewBox: 0 0 200 100

   Button Group Layout:
   /* Why center alignment? Users expect controls (B7/B8/B9/BR3) to be centered below content.
      Centered buttons feel symmetrical and organized.
      8px gap provides breathing room between small circular buttons. */
   - Display: flex, justify-content: center, gap: 8px
   - Margin-top: 8px

   Button Styling (B7/B8/B9):
   /* Why circular 32px buttons? "Sound mode" buttons should be minimal and icon-like.
      32px is large enough for touch targets (44px minimum for accessibility, but buttons are paired).
      Circular shape signals "toggle/mode switch"; not a primary action button.
      No text label keeps them visually light. Default #d0d0d0 = inactive; #a3d5ff = active mode. */
   - Shape: circular (border-radius: 50%)
   - Size: 32px × 32px
   - Default: #d0d0d0
   - Active: #a3d5ff with box-shadow

   Button Styling (BR3):
   /* Why different style (rounded square + text)? BR3 is the PRIMARY ACTION ("Load to R2B").
      Text "LR2B" labels the function explicitly. Light purple #c9b3ff differentiates BR3 from mode buttons.
      Rounded square (vs circular) signals "action button" instead of "mode toggle". */
   - Shape: rounded square (border-radius: 4px)
   - Padding: 6px 12px
   - Background: #c9b3ff
   - Font-size: 12px, font-weight: bold

12. JavaScript Implementation (Option B: Code Examples)

   /* ===== PURPOSE: Render pianos, receive chords from R1, compute voicings, play audio, send to R2B =====
      GOAL: Display chords as marked notes on piano SVGs; handle mode switches (triad/tetrad/inversion)
      KEY PRINCIPLE: rowIndex (1-10) maps 1:1 to R1 row input indices (critical for data integrity).
                     currentRowIndex persists when B7/B8/B9 mode switches (don't jump to different pianogroup).
                     Voicing computation happens in R3, not R1 (separation of concerns: R1 validates, R3 computes).
      ARCHITECTURE:
         1. renderPianoSVG() - Create 10 SVG pianos with 12 keys each (C-B), labeled
         2. receiveChordFromR1(chordName, rowIndex) - Single chord update for specific pianogroup
         3. receiveChordBatch(chordArray) - Bulk update for all 10 pianogroups (from R1 B3)
         4. updateChordDisplay(rowIndex, chordName, notes) - Mark notes green on piano
         5. handleB7/B8/B9Click() - Switch sound mode/inversion, preserve rowIndex, replay with new voicing
         6. handleBR3Click() - Send currentChord (full payload) to R2B
      ===== */

   Piano Rendering Function:
   /* Why renderPianoSVG(pianoGroupIndex)? Each pianogroup needs an SVG piano with properly laid-out keys.
      White keys (C, D, E, F, G, A, B) are rectangular; black keys (#, b) are smaller and offset.
      Each key needs id (e.g., "r3-piano-1-C") and data-note attribute for JavaScript queries.
      Labels ("C", "D", etc.) are visible on keys so users know which notes are which.
      Why draw all 12 keys? Users need to understand chord voicing positions. Hidden keys = confusing UX. */
   - renderPianoSVG(pianoGroupIndex): Creates SVG with 7 white + 5 black keys
   - Each key has id, data-note attribute, note name label
   - White keys: #f5f5f5 with #ccc border
   - Black keys: #1a1a1a with #000 border

   Update Chord Display Function:
   /* Why updateChordDisplay(pianoGroupIndex, chordName, notes)? This is called every time a chord is received.
      Chord label (e.g., "Cmaj7") goes above the piano for identification.
      Active chord notes get #8fd694 green fill (matches R1 highlight color).
      Clearing previous markings prevents visual artifacts (old notes lingering). */
   - updateChordDisplay(pianoGroupIndex, chordName, notes)
   - Sets chord label text
   - Marks active chord notes with #8fd694 fill
   - Clears previous markings

   Sound Mode Handlers:
   /* Why setSoundMode(mode)? When user clicks B7 (Triad), B8 (Tetrad), or B9 (Inversion),
      the sound playback should change immediately. Button UI also updates to show active mode.
      Crucially: current rowIndex does NOT change (pianogroup stays the same; just replayed with new voicing).
      Why cycle inversions 0-3 on B9? Inversions are: 0=root, 1=first, 2=second, 3=third.
      Cycling gives users four different voicings to hear/see for the same chord. */
   - setSoundMode(mode): Updates button UI, replays chord with new mode
   - handleB7Click: Set to 'triad' mode
   - handleB8Click: Set to 'tetrad' mode
   - handleB9Click: Set to 'inversion' mode, cycle inversions 0-3

   BR3 Send Handler:
   /* Why handleBR3Click()? BR3 sends the CURRENTLY ACTIVE chord (not a list) to R2B for analysis display.
      Payload includes: chordName, notes, mode, inversion, analysis, source:"R3", timestamp.
      Defensive check: only send if window.R2B exists and is ready (avoid errors if R2B not loaded).
      No-op if currentChord is null/undefined (user hasn't loaded any chord yet). */
   - handleBR3Click: Sends currentChord (full payload enligt kontrakt) till R2B (single chord)
   - Payload struktur: { chordName, notes, mode, inversion, analysis, source: "R3", timestamp }
   - Uses R2B.setChord(payload) with readiness check
   - No-op om currentChord saknas, innehåller ogiltig data, eller validering misslyckas
   - Skicka bara om window.R2B finns och (R2B.isReady() || r2b-ready-event mottagen)

   B7/B8/B9 Sound Mode with Recalculation (Row-Index Preservation):
   /* Why preserve rowIndex during mode switches? If user clicks B7 on row 5, then B8, then B9,
      all three operations should update the SAME pianogroup (row 5), not jump around.
      Implementation: currentRowIndex never changes during B7/B8/B9; only currentSoundMode/currentInversion change.
      Then re-compute notes using voicing rules, update pianogroup display, and replay audio.
      This is why B7/B8/B9 are called "Sound Mode Handlers" not "Row Select Handlers". */
   - Quando B7 (Triad), B8 (Tetrad), eller B9 (Inversion) clicked:
     * Update currentSoundMode or currentInversion accordingly
     * Current rowIndex is preserved (no pianogroup switch)
     * Recalculate notes using voicing-regler for current mode and inversion
     * Update currentChord.notes and currentChord.mode/inversion
     * Update pianogroup[currentRowIndex] display with newly computed notes
     * Play audio with new voicing
   - Optional: Send updated payload to R2B if changed (debounce to avoid spam)
   - Primär funktion kvarstår: ljudläge/inversion i R3

   Clear Pianogroup Function:
   - clearPianoGroup(rowIndex) – clears specific pianogroup by row index
   - rowIndex (1-10): specifies which pianogroup to clear
   - Sets chord name to "–" (dash/empty), clears marked notes
   - No sound playback
   - Called by R1 B2 (row-level clear) and B4 (global clear)
   - Example call from R1: R3.clearPianoGroup(1) clears R3.Pianogroup.1

   Batch Receive Function (for B3 global load):
   - receiveChordBatch(chordArray) – receives array of chords for all pianogroups
   - chordArray: Array of 10 elements where chordArray[i] is chord for pianogroup (i+1)
   - Empty strings (empty chords) result in cleared pianogroups
   - Processes all updates before sound playback begins
   - Each non-empty chord plays sequentially with ~400ms gap
   - Example call from R1: R3.receiveChordBatch(["C", "Dm", "G7", ..., ""])

   Data Reception from R1:
   - receiveChordFromR1(chordName, rowIndex) – receives chord name string and row index from R1
   - rowIndex (1-10): indicates which pianogroup to update (1:1 mapping with R1 rows)
   - Extracts chord quality from chordName
   - Computes voicing using voicing-regler (Section 9) for current mode (triad/tetrad) and inversion (0–3)
   - Generates notes array for display and audio playback
   - Updates pianogroup[rowIndex] display with chord name and marked notes
   - Plays sound based on currentSoundMode and currentInversion
   - Example call from R1: R3.receiveChordFromR1("Cmaj7", 1) updates R3.Pianogroup.1

   Initialization:
   - DOMContentLoaded: Render all 10 pianogroups, set default sound mode = 'triad', default inversion = 0
   - Initialize: currentRowIndex = null (no pianogroup active until first receiveChordFromR1 call)
   - Initialize: currentChord = null (no active chord until first receiveChordFromR1 call)
   - Create piano SVGs dynamically or use template
   - Ensure all state variables properly reset on page load

13. Implementation Checklist

   Before HTML Conversion:
   - [ ] Verify 10 pianogroups with IDs r3-pianogroup-1 to r3-pianogroup-10
   - [ ] Confirm piano graphic shows C–B (12 notes, 7 white + 5 black)
   - [ ] Verify note names on all keys
   - [ ] Confirm horizontal layout, no line breaks, kant-i-kant
   - [ ] Test R3 width = 85% viewport
   - [ ] Add ARIA labels to all buttons
   - [ ] Verify button colors: #d0d0d0 inactive, #a3d5ff active, #c9b3ff BR3
   - [ ] Confirm footer timestamp format

   Post-Implementation Testing:
   - [ ] Receive chord from R1 (B1/B3 trigger)
   - [ ] Chord name displayed correctly
   - [ ] Correct notes marked in green on piano
   - [ ] B7 (Triad) plays 3-note voicing
   - [ ] B8 (Tetrad) plays 4-note voicing with extension
   - [ ] B9 (Inversion) cycles 0–3 for tetrads
   - [ ] BR3 sends single chord to R2B (not list)
   - [ ] Sound playback ~400ms timing
   - [ ] Pianogroups resize proportionally
   - [ ] Keyboard support (Tab, focus outlines)
   - [ ] All chord qualities (maj/m/dim/aug/sus)
   - [ ] Voicing rules applied per sound mode
   - [ ] Cross-panel flow R2A→R1→R3 complete

