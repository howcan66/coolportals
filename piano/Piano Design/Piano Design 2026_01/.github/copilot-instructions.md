# AI Coding Guide for Piano Design 2026_01

- **System layout**: Four panels pipeline chords R2A → R1 → R3 → R2B. Single-page integration lives in [integration.html](integration.html); multi-iframe harness in [frame.html](frame.html). Standalone panels: [R1.html](R1.html), [R2A.html](R2A.html), [R3.html](R3.html), [R2B.html](R2B.html).
- **Run locally**: Open integration.html directly for zero CORS friction; use a localhost server (e.g., `python -m http.server 8000`) when testing frame.html so iframes share origin and can message each other.
- **Core API contract**: R1 → R3 only. Public functions on R3: `receiveChordFromR1(chordName, rowIndex)`, `receiveChordBatch(chordArray)`, `clearPianoGroup(rowIndex)`, optional `isReady()`. Contract and examples are in [R1-R3_API_Contract.txt](R1-R3_API_Contract.txt); verification notes in [R1-R3_INTERFACE_VERIFICATION.txt](R1-R3_INTERFACE_VERIFICATION.txt).
- **Row mapping**: R1 uses 1–10 (standalone) or 1–24 (integration) rows; rowIndex always maps 1:1 to R3 pianogroups. Batch arrays are zero-based (index i → row i+1). Empty string in a batch clears that pianogroup.
- **Validation rules**: Both R1 and R2A enforce the same regex allowing A–G/H with optional #/b, quality, extensions up to 10 chars. H is normalized to B before sending. Invalid or blank inputs are cleared and never forwarded.
- **Buttons (integration.html, 24-row variant)**: R1: B1 send single, B2 clear row, B3 batch send all, B4 clear all, B0 opens LR1O blank popup placeholder. R2A: B5 load selected row destructively into R1 then auto-fire B1 handlers; B6 clear textarea; B7 load all rows destructively; B8 clear all. R3 per-row: B7 triad mode, B8 tetrad, B9 cycle inversion, BR3 send current row to R2B. R2B: B10 reload/reset, B11 clear.
- **Buttons (standalone R1/R2A/R3/R2B)**: R1 has 10 rows with L/X per row, LR3 (B3) and XR1 (B4) global. R2A has 10 text areas with LR1/XR2A per row plus LR1 (all)/XR2A (all). R3 has 10 pianogroups with global T/Te/I/LR2B controls. R2B shows chord analysis and piano with B10/B11.
- **Chord voicing**: R3 computes voicings via `computeVoicing(chordName, mode, inversion)`; mode toggles triad/tetrad; inversion cycles 0–3. Notes arrays (e.g., ["C4","E4","G4"]) drive piano coloring and are passed to R2B for analysis. In integration.html a full chord table is embedded; standalone R3 uses a simplified mapping.
- **Audio hooks**: Audio playback is stubbed (console logs) in all panels; no external audio libs. If adding sound, keep R3 the single source of truth to avoid double playback (see timing notes in R1-R3 interface verification).
- **Storage/persistence**: R2A saves textarea content to localStorage per row on blur; loading clears R1 before writing. R1/R3/R2B do not persist state.
- **Analysis flow to R2B**: R3 sends payload `{ chordName, notes, mode, inversion, analysis, source, timestamp }` via BR3. R2B validates payload, colors keys, logs analysis fields (type/quality/intervals/position), and debounces play to prevent overlap.
- **UI/viewport assumptions**: Designed for desktop flex/grid layouts with compact fonts; colors hardcoded. Keep SVG piano sizes and aspect ratios when adding controls to avoid layout breakage.
- **Testing tips**: For multi-panel flow use integration.html (single document, no origin issues). For iframe orchestration use frame.html with a local server and watch the console for verbose integration logs.
- **Extending safely**: Preserve public API names and row indexing. Keep regex parity between R1 and R2A. When altering voicing/analysis, update both the embedded chord table (integration.html) and the simplified logic in R3.html to stay aligned.
